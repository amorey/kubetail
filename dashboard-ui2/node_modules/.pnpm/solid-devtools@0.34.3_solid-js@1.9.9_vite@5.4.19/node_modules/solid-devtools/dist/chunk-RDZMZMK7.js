// packages/main/src/babel/babel.ts
import * as babel from "@babel/core";
import * as t from "@babel/types";
import * as debug from "@solid-devtools/debugger/types";
import * as path from "node:path";
var NAME_ID = /* @__PURE__ */ t.identifier("name");
var UNDEFINED_ID = /* @__PURE__ */ t.identifier("undefined");
function equal(a, b) {
  if (a.type !== b.type) return false;
  switch (a.type) {
    case "Identifier":
    case "V8IntrinsicIdentifier":
      return a.name === b.name;
    case "PrivateName":
      return a.id === b.id;
    case "MemberExpression":
      return equal(a.object, b.object) && equal(a.property, b.property);
    default:
      return false;
  }
}
function addNameToOptions(node, arg_idx, name) {
  let name_property = t.objectProperty(NAME_ID, t.stringLiteral(name));
  while (node.arguments.length < arg_idx) {
    node.arguments.push(UNDEFINED_ID);
  }
  if (node.arguments.length === arg_idx) {
    node.arguments.push(t.objectExpression([name_property]));
  } else {
    const options = node.arguments[arg_idx];
    if (options.type !== "ObjectExpression") {
      return;
    }
    if (options.properties.some(
      (prop) => prop.type === "ObjectProperty" && prop.key.type === "Identifier" && prop.key.name === NAME_ID.name
    )) {
      return;
    }
    options.properties.unshift(name_property);
  }
}
var SOURCE_TYPES = {
  returning: /* @__PURE__ */ new Set(["createSignal", "createMemo", "createStore", "createMutable"]),
  effect: /* @__PURE__ */ new Set(["createEffect", "createRenderEffect", "createComputed"])
};
var SOURCE_MODULES = {
  "solid-js": /* @__PURE__ */ new Set([
    "createSignal",
    "createMemo",
    "createEffect",
    "createRenderEffect",
    "createComputed"
  ]),
  "solid-js/store": /* @__PURE__ */ new Set(["createStore", "createMutable"])
};
var OPTIONS_ARG_POS = {
  createSignal: 1,
  createMemo: 2,
  createStore: 1,
  createMutable: 1,
  createEffect: 2,
  createRenderEffect: 2,
  createComputed: 2
};
function getTarget(node, sources, includedOptions) {
  return Object.entries(sources).find(
    ([sourcesKey, someSources]) => includedOptions.has(sourcesKey) && someSources.some((source) => equal(node, source))
  )?.[0];
}
var Sources;
var FileWithImports = false;
var namePlugin = {
  name: "@solid-devtools/autoname",
  visitor: {
    Program() {
      Sources = {
        createSignal: [],
        createMemo: [],
        createStore: [],
        createMutable: [],
        createEffect: [],
        createRenderEffect: [],
        createComputed: []
      };
      FileWithImports = false;
    },
    // Track imported references to sources
    ImportDeclaration(path2) {
      const source = path2.node.source.value;
      const targets = SOURCE_MODULES[source];
      if (!targets) return;
      for (const s of path2.node.specifiers) {
        switch (s.type) {
          // import * as local from "solid-js"
          case "ImportNamespaceSpecifier":
            for (const target of targets) {
              Sources[target].push(t.memberExpression(s.local, t.identifier(target)));
              FileWithImports = true;
            }
            break;
          // import { createSignal } from "solid-js"
          // import { createSignal as local } from "solid-js"
          // import { "createSignal" as local } from "solid-js"
          case "ImportSpecifier": {
            const name = s.imported.type === "Identifier" ? s.imported.name : s.imported.value;
            if (targets.has(name)) {
              Sources[name].push(s.local);
              FileWithImports = true;
            }
            break;
          }
        }
      }
    },
    VariableDeclaration(path2) {
      if (!FileWithImports) return;
      for (const decl of path2.node.declarations) {
        if (!decl.init || decl.init.type !== "CallExpression") continue;
        const target = getTarget(decl.init.callee, Sources, SOURCE_TYPES.returning);
        if (!target) continue;
        let name;
        if (decl.id.type === "Identifier") {
          name = decl.id.name;
        } else if (decl.id.type === "ArrayPattern" && decl.id.elements[0]?.type === "Identifier") {
          name = decl.id.elements[0].name;
        } else {
          continue;
        }
        addNameToOptions(decl.init, OPTIONS_ARG_POS[target], name);
      }
    },
    CallExpression(path2) {
      if (!FileWithImports) return;
      const target = getTarget(path2.node.callee, Sources, SOURCE_TYPES.effect);
      if (!target) return;
      let name;
      let parent = path2.parentPath;
      for (let i = 0; i < 5; i++) {
        if (parent.node.type === "CallExpression" && parent.node.callee.type === "Identifier") {
          name = `to_${parent.node.callee.name}`;
          break;
        }
        if ((parent.node.type === "FunctionDeclaration" || parent.node.type === "VariableDeclarator") && parent.node.id?.type === "Identifier") {
          name = `in_${parent.node.id.name}`;
          break;
        }
        if (parent.parentPath) {
          parent = parent.parentPath;
        } else {
          break;
        }
      }
      if (name) {
        addNameToOptions(path2.node, 2, name);
      }
    }
  }
};
var isUpperCase = (s) => /^[A-Z]/.test(s);
var getLocationAttribute = (filePath, line, column) => `${filePath}:${line}:${column}`;
function getNodeLocationAttribute(node, filename, isJSX = false) {
  if (node.loc) {
    return getLocationAttribute(
      path.relative(process.cwd(), filename),
      node.loc.start.line,
      // 2 is added to place the caret after the "<" character
      node.loc.start.column + (isJSX ? 2 : 0)
    );
  }
}
var SDT_GET_OWNER = "$sdt_getOwner";
var solid_js_str = t.stringLiteral("solid-js");
var get_owner_ident = t.identifier("getOwner");
var sdt_get_owner_ident = t.identifier(SDT_GET_OWNER);
var jsx_location_attr = t.jsxIdentifier(debug.LOCATION_ATTRIBUTE_NAME);
function jsxLocationPlugin(config) {
  let file_transform = false;
  let file_imported = false;
  let file_filename = "";
  let file_program;
  const project_path_ast = babel.template(
    `globalThis.${debug.WINDOW_PROJECTPATH_PROPERTY} = %%loc%%;`
  )(
    {
      loc: t.stringLiteral(process.cwd())
    }
  );
  const buildSetComponentLocationAst = babel.template(
    `if (${SDT_GET_OWNER}()) ${SDT_GET_OWNER}().${debug.OWNER_LOCATION_PROP} = %%loc%%;`
  );
  function addLocationToBody(body, node) {
    let location = getNodeLocationAttribute(node, file_filename);
    if (location) {
      if (!file_imported) {
        file_imported = true;
        file_program.unshiftContainer("body", [
          t.importDeclaration(
            [t.importSpecifier(sdt_get_owner_ident, get_owner_ident)],
            solid_js_str
          )
        ]);
      }
      body.body.unshift(buildSetComponentLocationAst({ loc: t.stringLiteral(location) }));
    }
  }
  return {
    name: "@solid-devtools/location",
    visitor: {
      Program(path2, state) {
        file_transform = false;
        file_imported = false;
        file_filename = "";
        file_program = void 0;
        if (typeof state.filename === "string") {
          file_transform = true;
          file_filename = state.filename;
          file_program = path2;
          file_program.node.body.push(project_path_ast);
        }
      },
      ...config.jsx && {
        JSXOpeningElement(path2) {
          let { openingElement } = path2.container;
          if (file_transform && openingElement.name.type === "JSXIdentifier" && // Filter native elements
          !isUpperCase(openingElement.name.name)) {
            let location = getNodeLocationAttribute(openingElement, file_filename, true);
            if (location) {
              openingElement.attributes.push(
                t.jsxAttribute(jsx_location_attr, t.stringLiteral(location))
              );
            }
          }
        }
      },
      ...config.components && {
        FunctionDeclaration(path2) {
          if (file_transform && path2.node.id && isUpperCase(path2.node.id.name)) {
            addLocationToBody(path2.node.body, path2.node);
          }
        },
        VariableDeclarator(path2) {
          if (file_transform && "name" in path2.node.id && isUpperCase(path2.node.id.name) && path2.node.init && (path2.node.init.type === "FunctionExpression" || path2.node.init.type === "ArrowFunctionExpression") && path2.node.init.body.type === "BlockStatement") {
            addLocationToBody(path2.node.init.body, path2.node);
          }
        }
      }
    }
  };
}

export {
  namePlugin,
  SDT_GET_OWNER,
  jsxLocationPlugin
};
